% Copyright (C) Data Structures and Algorithms Team.
\chapter{Translation Walkthrough}
The conversion from pseudo to an actual imperative language is usually very straight forward, to clarify an example is provided.
In this example we will convert the algorithm in \S\ref{cha:Primality} to the C\# language.

\begin{tabbing}
1) pub\=lic static bool IsPrime(int number) \\
2) \{ \\
3) \> if (\=number $<$ 2) \\
4) \> \{ \\
5) \> \> return false; \\
6) \> \} \\ 
7) \> int innerLoopBound $=$ (int)Math.Floor(Math.Sqrt(number)); \\
8) \> for (int i $=$ 1; i $<$ number; i++) \\
9) \> \{ \\
10) \> \> for\= (int j $=$ 1; j $<=$ innerLoopBound; j++) \\
11) \> \> \{ \\
12) \> \> \> if (\=i $*$ j $==$ number) \\
13) \> \> \> \{ \\
14) \> \> \> \> return false; \\
15) \> \> \> \} \\
16) \> \> \} \\
17) \> \} \\
18) \> return true; \\
19) \} \\
\end{tabbing}

For the most part the conversion is a straight forward process, however you may have to inject various calls to other utility algorithms to ascertain the correct result.

A consideration to take note of is that many algorithms have fairly strict preconditions, of which there may be several - in these scenarios you will need to inject the correct code to handle such situations to preserve the correctness of the algorithm. Most of the preconditions can be suitably handled by throwing the correct exception.
