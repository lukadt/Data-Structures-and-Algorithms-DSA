% Copyright (C) Data Structures and Algorithms Team.
\chapter{Sorting}
All the sorting algorithms in this chapter use data structures of a specific type to demonstrate sorting, e.g. a $32$ bit integer is often used as its associated operations (e.g. $<$, $>$, etc) are clear in their behaviour.

The algorithms discussed can easily be translated into generic sorting algorithms within your respective language of choice.
\newpage
\section{Bubble Sort}
One of the most simple forms of sorting is that of comparing each item with every other item in some list, however as the description may imply this form of sorting is not particularly effecient $O(n^{2})$. In it's most simple form bubble sort can be implemented as two loops.

\begin{figure}[h]
\begin{center}
\includegraphics{sorting_bubble}
\end{center}
\caption{Bubble Sort Iterations} \label{fig:sorting_bubble}
\end{figure}

\begin{tabbing}
1)  \textbf{alg}\= \textbf{orithm} BubbleSort($list$) \\
2)  \> \textbf{Pre:}~~$list~!= \emptyset$ \\
3)  \> \textbf{Post:}~$list$ has been sorted into values of ascending order \\
4)  \> \textbf{for}\=~$i \leftarrow 0$ to $list.Count - 1$ \\
5)  \> \> \textbf{for}\=~$j \leftarrow 0$ to $list.Count - 1$ \\
6)  \> \> \> \textbf{if}~\= $list[i] < list[j]$ \\
7)  \> \> \> \> $Swap(list[i], list[j])$ \\
8)  \> \> \> \textbf{end if} \\
9)  \> \> \textbf{end for} \\
10) \> \textbf{end for} \\
11) \> \textbf{return} $list$ \\
12) \textbf{end} BubbleSort
\end{tabbing}

\section{Merge Sort}
Merge sort is an algorithm that has a fairly effecient space time complexity - $O(n~log~n)$ and is fairly trivial to implement. The algorithm is based on splitting a list, into two similar sized lists ($left$, and $right$) and sorting each list and then merging the sorted lists back together. \textit{Note: the function MergeOrdered simply takes two ordered lists and makes them one.}

\begin{figure}[h]
\begin{center}
\includegraphics{sorting_merge}
\end{center}
\caption{Merge Sort Divide et Impera Approach} \label{fig:sorting_merge}
\end{figure}

\begin{tabbing}
1)  \textbf{alg}\= \textbf{orithm} Mergesort($list$) \\
2)  \> \textbf{Pre:}~~$list~!=~\emptyset$ \\
3)  \> \textbf{Post:}~$list$ has been sorted into values of ascending order \\
4)  \> \textbf{if}~\= $list$.Count $= 1$ // already sorted \\
5)  \> \> \textbf{return}~$list$ \\
6)  \> \textbf{end if} \\
7)  \> $m \leftarrow list$.Count $/~2$ \\
8)  \> $left \leftarrow$ list($m$) \\
9)  \> $right \leftarrow$ list($list$.Count $-~m$) \\
10) \> \textbf{for}\=~$i \leftarrow 0$ to $left$.Count$-1$ \\
11) \> \> $left$[$i$] $\leftarrow$ list[$i$] \\
12) \> \textbf{end for} \\
13) \> \textbf{for}\=~$i \leftarrow 0$ to $right$.Count$-1$ \\
14) \> \> $right$[$i$] $\leftarrow$ list[$i$] \\
15) \> \textbf{end for} \\
16) \> $left \leftarrow$ Mergesort($left$) \\
17) \> $right \leftarrow$ Mergesort($right$) \\
18) \> \textbf{return} MergeOrdered($left$, $right$) \\
19) \textbf{end} Mergesort \\
\end{tabbing}

\newpage
\section{Quick Sort} 
Quick sort is one of the most popular sorting algorithms based on divide et impera strategy, resulting in an $O(n~log~n)$ complexity. The algorithm starts by picking an item, called pivot, and moving all smaller items before it, while all greater elements after it. This is the main quick sort operation, called partition, recursively repeated on lesser and greater sub lists until their size  is one or zero - in which case the list is implicitly sorted.

Choosing an appropriate pivot, as for example the median element is fundamental for avoiding the drastically reduced performance of $O(n^{2})$.

\begin{tabbing}
1)  \textbf{alg}\= \textbf{orithm} QuickSort($list$) \\
2)  \> \textbf{Pre:}~~$list~!=~\emptyset$ \\
3)  \> \textbf{Post:}~$list$ has been sorted into values of ascending order \\
4)  \> \textbf{if}~\= $list$.Count $= 1$ // already sorted \\
5)  \> \> \textbf{return}~$list$ \\
6)  \> \textbf{end if} \\
7)  \> $pivot \leftarrow $MedianValue($list$) \\
8)  \> \textbf{for}\=~$i \leftarrow 0$ to $list$.Count$-1$ \\
9)  \> \> \textbf{if}~\= $list[i] = pivot$ \\
10) \> \> \> $equal$.Insert$(list[i])$\\
11) \> \> \textbf{end if} \\
12) \> \> \textbf{if}~\= $list[i] < pivot$ \\
13) \> \> \> $less$.Insert$(list[i])$\\
14) \> \> \textbf{end if} \\
15) \> \> \textbf{if}~\= $list[i] > pivot$ \\
16) \> \> \> $greater$.Insert$(list[i])$\\
17) \> \> \textbf{end if} \\
18) \> \textbf{end for} \\
19) \> \textbf{return} Concatenate(QuickSort($less$),~$equal$,~QuickSort($greater$)) \\
20) \textbf{end} Quicksort \\
\end{tabbing}

\newpage
\section{Insertion Sort} \label{shell_sort}
Insertion sort is a somewhat interesting algorithm with an expensive runtime of $O(n^{2})$. It can be best thought of as a sorting scheme similar to that of sorting a hand of playing cards, i.e. you take one card and then look at the rest with the intent of building up an ordered set of cards in your hand.

\begin{tabbing}
1)  \textbf{alg}\= \textbf{orithm} Insertionsort($list$) \\
2)  \> \textbf{Pre:}~~ $list~!=~\emptyset$ \\
3)  \> \textbf{Post:}~$list$ has been sorted into values of ascending order \\
4)  \> $unsorted \leftarrow 1$ \\
5)  \> \textbf{whi}\= \textbf{le} $unsorted < list$.Count \\
6)  \> \> $hold \leftarrow list$[$unsorted$] \\
7)  \> \> $i \leftarrow unsorted - 1$ \\
8)  \> \> \textbf{whi}\= \textbf{le} $i \geq 0$ \textbf{and} $hold < list$[$i$] \\
9)  \> \> \> $list$[$i + 1$] $\leftarrow$ $list$[$i$] \\
10) \> \> \> $i \leftarrow i - 1$ \\
11) \> \> \textbf{end while} \\
12) \> \> $list$[$i+1$] $\leftarrow hold$ \\
13) \> \> $unsorted \leftarrow unsorted + 1$ \\
14) \> \textbf{end while} \\
15) \> \textbf{return} $list$ \\
16) \textbf{end} Insertionsort \\
\end{tabbing}

\newpage
\section{Shell Sort}
Put simply shell sort can be thought of as a more efficient variation of insertion sort as described in \S\ref{shell_sort}, it achieves this mainly by comparing items of varying distances apart resulting in a run time complexity of $O(n~log^{2}~n)$.

Shell sort is fairly straight forward but may seem somewhat confusing at first as it differs from other sorting algorithms in the way it selects items to compare. 

\begin{tabbing}
1)  \textbf{alg}\= \textbf{orithm} ShellSort($list$) \\
2)  \> \textbf{Pre:}~~$list~!=~\emptyset$ \\
3)  \> \textbf{Post:}~$list$ has been sorted into values of ascending order \\
4)  \> $increment \leftarrow list$.Count $/~2$ \\
5)  \> \textbf{whi}\= \textbf{le} $increment~!= 0$ \\
6)  \> \> $current \leftarrow increment$ \\
7)  \> \> \textbf{whi}\= \textbf{le} $current < list$.Count \\
8)  \> \> \> $hold \leftarrow list$[$current$] \\
9)  \> \> \> $i \leftarrow current - increment$ \\
10) \> \> \> \textbf{whi}\= \textbf{le} $i \geq 0$ \textbf{and} $hold < list$[$i$] \\
11) \> \> \> \> $list$[$i + increment$] $\leftarrow list$[$i$] \\
12) \> \> \> \> $i -= increment$ \\
13) \> \> \> \textbf{end while} \\
14) \> \> \> $list$[$i + increment$] $\leftarrow hold$ \\
15) \> \> \> $current \leftarrow current + 1$ \\
16) \> \> \textbf{end while} \\
17) \> \> $increment~/= 2$ \\
18) \> \textbf{end while} \\
19) \> \textbf{return} $list$ \\
20) \textbf{end} ShellSort \\
\end{tabbing}

