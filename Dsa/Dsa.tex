\documentclass[10pt,oneside,a4paper]{report}
\usepackage{url}
\begin{document}

\title{Data Structures and Algorithms\\Pseudocode}
\author{Granville Barnett\\Luca Del Tongo}
\maketitle

\newpage
\tableofcontents
\newpage

\section*{Preface}
This book consists of annotated pseudocode that was used when designing the algorithms which are contained in DSA\footnote{\url{http://codeplex.com/dsa}}. In DSA all implementations are in C\# \footnote{\url{http://msdn.microsoft.com/en-us/vcsharp/default.aspx}}.

The designs provided here serve as a reference for those who want to port well designed and tested implementations of common (and uncommon) data structures and algorithms to their imperative language of choice.

\pagestyle{headings}

\part{Data Structures}

\part{Algorithms}

\chapter{Sorting}
Test.

\chapter{Numeric}
\section{Primality Test} \label{cha:Primality}
A simple algorithm that determines whether or not a given integer is a prime number, e.g. $2$, $5$, $7$, and $13$ are \textbf{all} prime numbers, however $6$ is not as it can be the result of the product of two numbers that are $< 6$.

In an attempt to slow down the inner loop the $\sqrt{n}$ is used as the upper bound.

\begin{tabbing}
1) \textbf{alg}\= \textbf{orithm} IsPrime($n$)\\
2) \> \textbf{for} \= $i \leftarrow 2$ \textbf{to} $n$ \textbf{do}\\
3) \> \> \textbf{for} \= $j \leftarrow 1$ \textbf{to} $sqrt(n)$ \textbf{do}\\
4) \> \> \> \textbf{if} ~\= $i * j = n$\\
5) \> \> \> \> \textbf{return} false\\
6) \> \> \> \textbf{end if}\\
7) \> \> \textbf{end for}\\	
8) \> \textbf{end for}\\
9) \textbf{end} IsPrime
\end{tabbing}

\section{Base conversions}
DSA contains a number of algorithms that convert a base $10$ number to its equivalent binary, octal or hexadecimal form. For example $78_{10}$ has a binary representation of $1001110_{2}$.

\begin{tabbing}
1) \textbf{alg}\= \textbf{orithm} ToBinary($n$)\\
2) \> \textbf{whi}\= \textbf{le} $n > 0$\\
3) \> \> $list.Add(n~\%~2)$\\
4) \> \> $n \leftarrow n / 2$\\
5) \> \textbf{end while}\\
6) \textbf{end} ToBinary\\
\end{tabbing}

\appendix
\chapter{Translation Walkthrough}
The conversion from pseudo to an actual imperative language is usually very straight forward, to clarify an example is provided.
In this example we will convert the algorithm in \S\ref{cha:Primality} to the C\# language.

\begin{tabbing}
1) pub\=lic static bool IsPrime(int number) \\
2) \{ \\
3) \> if (\=number $<$ 2) \\
4) \> \{ \\
5) \> \> return false; \\
6) \> \{ \\ 
7) \> int innerLoopBound $=$ (int)Math.Floor(Math.Sqrt(number)); \\
8) \> for (int i $=$ 1; i $<$ number; i++) \\
9) \> \{ \\
10) \> \> for\= (int j $=$ 1; j $<=$ innerLoopBound; j++) \\
11) \> \> \{ \\
12) \> \> \> if (\=i $*$ j $==$ number) \\
13) \> \> \> \{ \\
14) \> \> \> \> return false; \\
15) \> \> \> \} \\
16) \> \> \} \\
17) \> \} \\
18) \> return true; \\
19) \} \\
\end{tabbing}

For the most part the conversion is a straight forward process, however you may have to inject various calls to other utility algorithms to ascertain the correct result.

\chapter{Symbol Definitions}
Throughout the pseudocode listings you will find several symbols used,  describes the meaning of each of those symbols.

\end{document}
