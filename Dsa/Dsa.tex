\documentclass[10pt,oneside,a4paper]{report}
\usepackage{url}
\usepackage{ifsym}
\begin{document}

\title{Data Structures and Algorithms\\Pseudocode}
\author{Granville Barnett\\Luca Del Tongo}
\maketitle

\newpage
\tableofcontents
\newpage

\section*{Preface}
This book consists of annotated pseudocode that was used when designing the algorithms which are contained in DSA\footnote{\url{http://codeplex.com/dsa}}. In DSA all implementations are in C\# \footnote{\url{http://msdn.microsoft.com/en-us/vcsharp/default.aspx}}.

The designs provided here serve as a reference for those who want to port well designed and tested implementations of common (and uncommon) data structures and algorithms to their imperative language of choice.

\pagestyle{headings}

\part{Data Structures}

\chapter{Linked Lists}
\section{Singly Linked List}
\section{Doubly Linked List}

\chapter{Binary Search Tree}

\chapter{Heap}

\chapter{Sets}
\section{Unordered}
\section{Ordered}

\chapter{Queues}
\section{Standard Queue}
\section{Priority Queue}

\chapter{Balanced Trees}
\section{AVL Tree}

\part{Algorithms}

\chapter{Sorting}
All the sorting algorithms in this chapter use data structures of a specific type to demonstrate sorting, e.g. a $32$ bit integer is often used as its associated operations (e.g. $<$, $>$, etc) are clear in their behaviour.

The algorithms discussed can easily be translated into generic sorting algorithms within your respective language of choice.

\section{Bubble Sort}
One of the most simple forms of sorting is that of comparing each item with every other item in some list, however as the description may imply this form of sorting is not particularly effecient $O(n^{2})$.

In it's most simple form bubble sort can be implemented as two loops.

\begin{tabbing}
1)  \textbf{alg}\= \textbf{orithm} BubbleSort($list$) \\
2)  \> \textbf{Pre:}~~$list~!= \emptyset$ \\
3)  \> \textbf{Post:}~$list$ has been sorted into values of ascending order \\
4)  \> \textbf{for}\=~$i \leftarrow 0$ to $list.Count - 1$ \\
5)  \> \> \textbf{for}\=~$j \leftarrow 0$ to $list.Count - 1$ \\
6)  \> \> \> \textbf{if}~\= $list[i] < list[j]$ \\
7)  \> \> \> \> $Swap(list[i], list[j])$ \\
8)  \> \> \> \textbf{end if} \\
9)  \> \> \textbf{end for} \\
10) \> \textbf{end for} \\
11) \> \textbf{return} $list$ \\
12) \textbf{end} BubbleSort
\end{tabbing}

\section{Merge Sort}
Merge sort is an algorithm that has a fairly effecient space time complexity - $O(n~log~n)$ and is fairly trivial to implement.

The algorithm is based on splitting a list, into two similar sized lists ($left$, and $right$) and sorting each list and then merging the sorted lists back together.

\textit{Note: the function MergeOrdered simply takes two ordered lists and makes them one.}

\begin{tabbing}
1)  \textbf{alg}\= \textbf{orithm} Mergesort($list$) \\
2)  \> \textbf{Pre:}~~$list~!=~\emptyset$ \\
3)  \> \textbf{Post:}~$list$ has been sorted into values of ascending order \\
4)  \> \textbf{if}~\= $list$.Count $= 1$ // already sorted \\
5)  \> \> \textbf{return}~$list$ \\
6)  \> \textbf{end if} \\
7)  \> $m \leftarrow list$.Count $/~2$ \\
8)  \> $left \leftarrow$ list($m$) \\
9)  \> $right \leftarrow$ list($list$.Count $-~m$) \\
10) \> \textbf{for}\=~$i \leftarrow 0$ to $left$.Count$-1$ \\
11) \> \> $left$[$i$] $\leftarrow$ list[$i$] \\
12) \> \textbf{end for} \\
13) \> \textbf{for}\=~$i \leftarrow 0$ to $right$.Count$-1$ \\
14) \> \> $right$[$i$] $\leftarrow$ list[$i$] \\
15) \> \textbf{end for} \\
16) \> $left \leftarrow$ Mergesort($left$) \\
17) \> $right \leftarrow$ Mergesort($right$) \\
18) \> \textbf{return} MergeOrdered($left$, $right$) \\
19) \textbf{end} Mergesort \\
\end{tabbing}

\section{Insertion Sort}
Insertion sort is a somewhat interesting algorithm with an expensive runtime of $O(n^{2})$. It can be best thought of as a sorting scheme similar to that of sorting a hand of playing cards, i.e. you take one card and then look a the rest with the intent of building up an ordered set of cards in your hand.

\begin{tabbing}
1)  \textbf{alg}\= \textbf{orithm} Insertionsort($list$) \\
2)  \> \textbf{Pre:}~~ $list~!=~\emptyset$ \\
3)  \> \textbf{Post:}~$list$ has been sorted into values of ascending order \\
4)  \> $unsorted \leftarrow 1$ \\
5)  \> \textbf{whi}\= \textbf{le} $unsorted < list$.Count \\
6)  \> \> $hold \leftarrow list$[$unsorted$] \\
7)  \> \> $i \leftarrow unsorted - 1$ \\
8)  \> \> \textbf{whi}\= \textbf{le} $i \geq 0$ \textbf{and} $hold < list$[$i$] \\
9)  \> \> \> $list$[$i + 1$] $\leftarrow$ $list$[$i$] \\
10) \> \> \> $i \leftarrow i - 1$ \\
11) \> \> \textbf{end while} \\
12) \> \> $list$[$i+1$] $\leftarrow hold$ \\
13) \> \> $unsorted \leftarrow unsorted + 1$ \\
14) \> \textbf{end while} \\
15) \> \textbf{return} $list$ \\
16) \textbf{end} Insertionsort \\
\end{tabbing}

\section{Shell Sort}
\begin{tabbing}
1)  \textbf{alg}\= \textbf{orithm} ShellSort($list$) \\
2)  \> \textbf{Pre:}~~$list~!=~\emptyset$ \\
3)  \> \textbf{Post:}~$list$ has been sorted into values of ascending order \\
4)  \> $increment \leftarrow list$.Count $/~2$ \\
5)  \> \textbf{whi}\= \textbf{le} $increment~!= 0$ \\
6)  \> \> $current \leftarrow increment$ \\
7)  \> \> \textbf{whi}\= \textbf{le} $current < list$.Count \\
8)  \> \> \> $hold \leftarrow list$[$current$] \\
9)  \> \> \> $i \leftarrow current - increment$ \\
10) \> \> \> \textbf{whi}\= \textbf{le} $i \geq 0$ \textbf{and} $hold < list$[$i$] \\
11) \> \> \> \> $list$[$i + increment$] $\leftarrow list$[$i$] \\
12) \> \> \> \> $i -= increment$ \\
13) \> \> \> \textbf{end while} \\
14) \> \> \> $list$[$i + increment$] $\leftarrow hold$ \\
15) \> \> \> $current \leftarrow current + 1$ \\
16) \> \> \textbf{end while} \\
17) \> \> $increment~/= 2$ \\
18) \> \textbf{end while} \\
19) \> \textbf{return} $list$ \\
20) \textbf{end} ShellSort \\
\end{tabbing}

\chapter{Numeric}
Unless stated otherwise the alias $n$ denotes a standard $32$ bit integer.

\section{Primality Test} \label{cha:Primality}
A simple algorithm that determines whether or not a given integer is a prime number, e.g. $2$, $5$, $7$, and $13$ are \textbf{all} prime numbers, however $6$ is not as it can be the result of the product of two numbers that are $< 6$.

In an attempt to slow down the inner loop the $\sqrt{n}$ is used as the upper bound.

\begin{tabbing}
1) \textbf{alg}\= \textbf{orithm} IsPrime($n$)\\
2) \> \textbf{Post:} $n$ is determined to be a prime or not \\
3) \> \textbf{for} \= $i \leftarrow 2$ \textbf{to} $n$ \textbf{do}\\
4) \> \> \textbf{for} \= $j \leftarrow 1$ \textbf{to} $sqrt(n)$ \textbf{do}\\
5) \> \> \> \textbf{if}~\= $i * j = n$\\
6) \> \> \> \> \textbf{return} false\\
7) \> \> \> \textbf{end if}\\
8) \> \> \textbf{end for}\\	
9) \> \textbf{end for}\\
10) \textbf{end} IsPrime
\end{tabbing}

\section{Base conversions}
DSA contains a number of algorithms that convert a base $10$ number to its equivalent binary, octal or hexadecimal form. For example $78_{10}$ has a binary representation of $1001110_{2}$.

\begin{tabbing}
1) \textbf{alg}\= \textbf{orithm} ToBinary($n$)\\
2) \> \textbf{Pre:}~~$n \geq 0$ \\
3) \> \textbf{Post:}~$n$ has been converted into its base $2$ representation \\
4) \> \textbf{whi}\= \textbf{le} $n > 0$\\
5) \> \> $list.Add(n~\%~2)$\\
6) \> \> $n \leftarrow n / 2$\\
7) \> \textbf{end while}\\
8) \textbf{end} ToBinary\\
\end{tabbing}

\chapter{Searching}

\section{Sequential Search}
A simple algorithm that search for a specific item inside a list. It operates looping on each element $O(n)$ until a match occurs or the end is reached.


\begin{tabbing}
1) \textbf{alg}\= \textbf{orithm} SequentialSearch($list$, $item$)\\
2) \> \textbf{Pre:}~~ $list~!=~\emptyset$ \\
3) \> \textbf{Post:}~ return $index$ of item if found, otherwise $-1$ \\
4) \> \= $index \leftarrow 0$ \\
5) \> \textbf{whi}\= \textbf{le} $index < list$.Count  \textbf{and} $list$[$index$]~!= $item$ \\
6) \> \> \= $index \leftarrow index+1$ \\
7) \> \textbf{end while} \\
8) \> \textbf{if }\= $ index < list$.Count  \textbf{and} $list$[$index$] = $item$ \\
9) \> \> \textbf{return} $index$ \\
10)\> \textbf{end if} \\
11)\> \textbf{return} $-1$ \\ 

\end{tabbing}

\section{Probability Search}
Probability Search is a statistical sequential search algorithm. In addition to search for an \textbf{item}, it takes into account its \textbf{frequency} by swapping it with it's predecessor in the list. The algorithm complexity still remain an $O(n)$ but in a non-uniform items search the more frequent items are in the first positions, reducing list scanning time.
\begin{tabbing}
1) \textbf{alg}\= \textbf{orithm} ProbabilitySearch($list$, $item$)\\
2) \> \textbf{Pre:}~~ $list~!=~\emptyset$ \\
3) \> \textbf{Post:}~ a boolean indicating where the item is found or not;\\
   \>~~~~~~~~~ in the former case swap founded item with its predecessor \\
4) \> \= $index \leftarrow 0$ \\
5) \> \textbf{whi}\= \textbf{le} $index < list$.Count  \textbf{and} $list$[$index$]~!= $item$ \\
6) \> \> \= $index \leftarrow index+1$ \\
7) \> \textbf{end while} \\
8) \> \textbf{if }\= $ index \geq list$.Count  \textbf{or} $list$[$index$] ~!= $item$ \\
9) \> \> \textbf{return} false \\
10)\> \textbf{end if} \\
11)\> \textbf{if }\= $ index > 0$ \\
12)\> \> $Swap(list[index], list[index-1])$ \\
13)\> \textbf{end if } \\
14)\> \textbf{return} true \\ 

\end {tabbing}

\chapter{Sets}

\chapter{Strings}

\appendix
\chapter{Translation Walkthrough}
The conversion from pseudo to an actual imperative language is usually very straight forward, to clarify an example is provided.
In this example we will convert the algorithm in \S\ref{cha:Primality} to the C\# language.

\begin{tabbing}
1) pub\=lic static bool IsPrime(int number) \\
2) \{ \\
3) \> if (\=number $<$ 2) \\
4) \> \{ \\
5) \> \> return false; \\
6) \> \{ \\ 
7) \> int innerLoopBound $=$ (int)Math.Floor(Math.Sqrt(number)); \\
8) \> for (int i $=$ 1; i $<$ number; i++) \\
9) \> \{ \\
10) \> \> for\= (int j $=$ 1; j $<=$ innerLoopBound; j++) \\
11) \> \> \{ \\
12) \> \> \> if (\=i $*$ j $==$ number) \\
13) \> \> \> \{ \\
14) \> \> \> \> return false; \\
15) \> \> \> \} \\
16) \> \> \} \\
17) \> \} \\
18) \> return true; \\
19) \} \\
\end{tabbing}

For the most part the conversion is a straight forward process, however you may have to inject various calls to other utility algorithms to ascertain the correct result.

A consideration to take note of is that many algorithms have fairly strict preconditions, of which there may be several - in these scenarios you will need to inject the correct code to handle such situations to preserve the correctness of the algorithm. Most of the preconditions can be suitably handled by throwing the correct exception.

\chapter{Symbol Definitions}
Throughout the pseudocode listings you will find several symbols used,  describes the meaning of each of those symbols.

\begin{tabular}[t]{|c|l|}
\hline
\textbf{Symbol} & \textbf{Description} \\
\hline
$\leftarrow$ & Assignment. In most imperative languages this equates to $=$ \\
\hline
$=$ & Equality. Most imperative languages use $==$ to denote a check for equality. \\
\hline
$\leq$ & Less than or equal to. Commonly this is denoted as $<=$ in imperative languages. \\
\hline
$<$ & Less than.* \\
\hline
$\geq$ & Greater than or equal to. Commonly this is denoted as $>=$ in imperative languages. \\
\hline
$>$ & Greater than.* \\
\hline
$!=$ & Inequality. * \\
\hline
$\emptyset$ & Null. \\
\hline
\textbf{and} & Logical and. Commonly \&\& in imperative languages. \\
\hline
\textbf{or} & Logical or. Commonly || in imperative languages. \\ % should be using \StrokeTwo but I get an error
\hline
\end{tabular}

* This symbol has a direct translation with the vast majority of imperative counterparts.

\end{document}
