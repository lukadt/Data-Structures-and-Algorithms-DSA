-------------------------------------------------------------------------------------------------------------------------------------------------

/* An algorithm to insert a node into the BST at the correct  position */
algorithm Insert (value)
	Pre: 	value is an integer or a type that supports math < operator
	Post: 	the node is either assigned as the root or a child of the root in the appropriate place
	if the root node is null
		insert the new node here
	else
		call the recursive InsertNode function passing the root node and value as parameters
	end if
end Insert

algorithm InsertNode (node <node>, value <integer>)
	Pre:	node is initially the root node and is not null
	Post:	each node is located in the correct position within the tree
	if value < node.Value // value is < current nodes value so go left in the tree
		if node.Left = null
			n.Left <- value // we have found a place to insert the new value
		else
			InsertNode(node.Left, value)
		end if
	else // the value is >= to the current nodes' value
		if node.Right = null
			node.Right <- value // we have found a place to insert the new value
		else
			InsertNode(node.Right, value)
		end if
	end if
end InsertNode

-------------------------------------------------------------------------------------------------------------------------------------------------

/* Preorder traversal passing each node on the left */
algorithm Preorder (root <node>)
	Pre:  	root is the root node of the tree
	Post:	each node is visited and value is printed when we pass the node on the left
	if root != null
		display the current nodes value
		Make a recursive call to Preorder passing the current nodes left child as the parameter to Preorder
		Make a recursive call to Preorder the current nodes right child as the parameter to Preorder
	end if
end Preorder

-------------------------------------------------------------------------------------------------------------------------------------------------

/* Postorder traversal passing each node on the left */
algorithm Postorder (root <node>)	
	Pre:	root is the root node of the tree
	Post:	each node is visited and value is printed when we pass the node on the right
	if root != null
		make a recursive call to Postorder passing the left child of the current node as the parameter
		make a recursive call to Postorder passing the right child of the current node as the parameter
		display the current nodes value
	end if
end Postorder

-------------------------------------------------------------------------------------------------------------------------------------------------

/* Inorder Travesal passing each node underneath */
algorithm Inorder (root <node>) 
	Pre:	root is the root node of the tree
	Post:	each node is visited and value is printed when passing underneath the node
	if root != null
		make a recursive call to Inorder passing the left child of the current node as the parameter
		display the current nodes value
		make a recursive call to Inorder passing the right child of the current node as the parameter
	end if
end Inorder

-------------------------------------------------------------------------------------------------------------------------------------------------

/* Breadth First traversal, traveses nodes per depth */
algorithm BreadthFirst (root <node>) 
	Pre:		root is the root node of the tree
				root is not null
				q is a queue
				l is a list
	Post:		each item in the tree is visited
	Returns:	a list l containing the items in breadth first order
	while root != null
		l.Add(root.Value) // add the current nodes value to the list
		if root.Left != null
			q.Enqueue(root.Left) // store the node in the queue to visit later
		end if
		if root.Right != null
			q.Enqueue(root.Right) // store the node in the queue to visit later
		end if
		if q not empty
			root <- q.Dequeue() // root is the first node in the queue
		else
			root <- null // we have ran out of nodes to visit
		end if
	end while
end BreadthFirst

-------------------------------------------------------------------------------------------------------------------------------------------------

/* find smallest value in bst */
algorithm FindMin(root <node>) 
	Pre:		root is root node of the tree
				root is not null
	Post:		Smallest value in bst is located
	Returns:	Smallest value in bst
	if root.Left = null // if the left child of the current node is null then we have found the smallest value in the tree
		return root.Value
	end if
	FindMin(root.Left) // continue walking down the left side of the tree to locate smallest value
end FindMin

-------------------------------------------------------------------------------------------------------------------------------------------------

/* find largest value in bst */
algorithm FindMax(root <node>) 
	Pre:		root is root node of the tree
				root is not null
	Post:		largest value in the bst is located
	Returns:	largest value in the bst
	if root.Right = null // if the right child of the current node is null then we have found the largest value in the tree
		return root.Value 
	end if
	return FindMax(root.Right) // continue walking down the right side of the tree to locate largest value
end FindMax

-------------------------------------------------------------------------------------------------------------------------------------------------

/* contains checks to see if the bst contains a specified item */
algorithm Contains(root <node>, item <integer>)
	Pre:		root is the root node of the tree
				item is the item to be located in the bst
	Post:		the item is either located or not
	Returns:	true if the item is located, false otherwise
	if root = null // if the root is null then we have exhausted all the nodes in the tree, thus the item isn't in the bst
		return false
	end if
	if root.Value = item // we have found the item
		return true
	else if item < root.Value
		return Contains(root.Left, item) // search the left subtree of the current node for the item
	else
		return Contains(root.Right, item) // search the right subtree of the current node for the item
	end if
end Contains

-------------------------------------------------------------------------------------------------------------------------------------------------

algorithm Delete (root <node>, value <integer>)
	Pre:		root is the root node of the bst
	Post:		the node with the value specified is deleted
	Returns:	true if the node was delelted, false otherwise
	if node = null
		return false // value wasn't found so can't delete
	end if
	if value < root.Value
		return Delete(root.Left, value)
	else if value > root.Value
		return Delete(root.Right, value)
	else // we have found the value
		if root.Left = null
			root <- root.Right
			return true
		else if root.Right = null
			root <- root.Left
			return true
		else // the node to delete isn't a leaf, find the largest value in the left subtree
			Node n <- root
			while n.Right != null
				n = n.Right
			end while // we have the largest value in the left subtree
			root.Value <- n.Value // replace the node to delete value with the largest value we found in the left subtree
			return true
		end if
	end if
end Delete

-------------------------------------------------------------------------------------------------------------------------------------------------

/* find a reference to a node with a given value */

algorithm FindNode(value <integer>, root <node>)
	Pre:		value is the value we are looking for a node to contain
				root is the root node of the bst
	Post:		the node with the specified value is either found or not
	Returns:	a reference to a node if a node with the specified value was found, otherwise null
	if root = null
		return null // there is no node with that value
	end if
	if value < root.Value
		return FindNode(value, root.Left) // go left in the tree as the value specified is less than the current nodes value
	else if value > root.Value
		return FindNode(value, root.Right) // go right in the tree as the value specified is greater than the current nodes value
	else
		return root // we have found the node with the specified value
	end if
end FindNode




