-------------------------------------------------------------------------------------------------------------------------------------------------

/*  
Bubblesort  
O(n^2). Sorts items of array in asc order.
*/
algorithm Bubblesort (array) 
	Pre:		array is an array of integers.
	Post:		a sorted array from lowest to highest values.
	Returns:	a sorted array.
	for i <- 0 to array.Length - 1
		for j <- 0 to array.Length - 1
			if array[i] < array[j] 
				swap i and j around // i < j so swap the items around
			end if
		end for
	end for
	return array // the sorted array
end Bubblesort

-------------------------------------------------------------------------------------------------------------------------------------------------

/* Merge ordered arrays
 * O(n).
 */
algorithm MergeOrdered (a1 <array>, a2 <array>)
	Pre:		a1 and a2 are not null
				a1 and a2 contain at least 1 item each
				a1 and a2 are already ordered
	Post:		both arrays are merged into a single ordered array
	Returns:	the single ordered merged array
	merged <- array[a1.Length + a2.Length]
	// merge all the items in both arrays
	for i <- 0, j <- 0, m <- 0; m < merged.Length; m++
		if i = a1.Length
			// we have exhausted all items from a1
			// copy items from a2 starting at index j to merged
		else if j = a2.Length
			// we have exhausted all items from a2
			// copy items from a1 starting at index i to merged
		else
			if a1[i] < a2[j]
				merged[m] <- a1[i++]
			else
				merged[m] <- a2[j++]
			end if
		end if
	end for
	return merged
end MergeOrdered

-------------------------------------------------------------------------------------------------------------------------------------------------

/* Merge sort algorithm
 * Note: MergeSort uses the MergeOrdered function as well.
 * O(n log n).
 */
algorithm MergeSort (value <array>)
	Pre:		value is not null
	Post:		value has been sorted in ascending order
	Returns:	sorted value array
	if value.Length = 1
		return value // base case an array with only one value is already sorted
	else
		m <- value.Length / 2
		left <- array[m]
		right <- array[value.Length - m]
		// populate left and right arrays with appropriate items from value
		for i <- 0; i < left.Length; i++
			left[i] <- value[i]
		end for
		for i <- 0; i < right.Length; i++, m++
			right[i] <- value[m]
		end for
		// apply the function recursively to both left and right arrays to get two sorted arrays
		left <- MergeSort(left)
		right <- MergeSort(right)
		// merge the two sorted arrays usin the MergeOrdered function
		return MergeOrdered(left, right)
	end if
end MergeSort